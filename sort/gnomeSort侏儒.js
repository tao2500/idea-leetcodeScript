// 思想：从头(i=0)开始遍历元素，如果当前元素比前一个元素小(array[i] < array[i-1])，就把它跟前一个元素互换,并继续检查i--位置元素大小
// 否则检查下一个元素(i++)。当i=length时结束排序，时间复杂度O（n^2）,最好O(N),空间复杂度O（1），稳定算法
// 对比侏儒排序和直接插入排序。会发现这二者的排序思想一模一样，但是插入排序有2处优化是侏儒排序没做到的：
// 1. 插入排序遇到不匹配位置的新元素时，把前面的元素挨个后移，然后把新元素直接插入到合适位置（如果位置移动k位，则赋值k+1次）。
// 而侏儒排序是把新元素逐个和前一个元素作交换，一路换位到合适位置，这是典型的冒泡做法（如果位置移动k位，则赋值3*k次）。
// 2. 当一个元素好不容易从第10位冒泡到第1位的时候，那么此时前10位一定是有序序列。插入排序会直接从第11位继续处理，
// 而侏儒排序只能从第2位继续处理，因为它不知道上个元素是从哪个位置走到第1位的，只好多走冤枉路。此处为了少走弯路采用变量j记录下次应排序的位置

function gnomeSort(arr) {
  let i = 1;
  let j = 2;
  while (i < arr.length) {
    if (arr[i - 1] <= arr[i]) {
      i = j;
      j++;
    } else {
      [arr[i - 1], arr[i]] = [arr[i], arr[i - 1]];
      i -= 1;
      if (i === 0) {
        i = j;
        j++;
      }
    }
  }
}
const arr = [9, 7, 5, 11, 12, 2, 14, 3, 10, 6];
gnomeSort(arr);
console.log(arr);
